<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="style.css">
<script src="script.js"></script>
<title>VFMADDSUB132PH/VFMADDSUB213PH/VFMADDSUB231PH - Fused Multiply-Alternating Add/Subtract of Packed FP16 Values </title></head>
<body>
<div id="head">
<a href="index.html">x86doc</a> › VFMADDSUB132PH/VFMADDSUB213PH/VFMADDSUB231PH - Fused Multiply-Alternating Add/Subtract of Packed FP16 Values </div>
<div id="body">
<h1>VFMADDSUB132PH/VFMADDSUB213PH/VFMADDSUB231PH—Fused Multiply-Alternating Add/Subtract of Packed FP16 Values</h1>
<table>
<tr>
<th>Opcode/Instruction</th>
<th>Op/En</th>
<th>64/32 bit Mode Support</th>
<th>CPUID Feature Flag</th>
<th>Description</th></tr>
<tr>
<td>EVEX.128.66.MAP6.W0  96  /r VFMADDSUB132PH  xmm1{k1}{z}, xmm2,  xmm3/m128/m16bcst</td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16 AVX512VL</td>
<td>
<p>Multiply packed FP16 values from xmm1 and</p>
<p>xmm3/m128/m16bcst, add/subtract elements in</p>
<p>xmm2, and store the result in xmm1 subject to writemask k1.</p></td></tr>
<tr>
<td>EVEX.256.66.MAP6.W0  96  /r VFMADDSUB132PH  ymm1{k1}{z}, ymm2,  ymm3/m256/m16bcst</td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16 AVX512VL</td>
<td>Multiply packed FP16 values from ymm1 and ymm3/m256/m16bcst, add/subtract elements in ymm2, and store the result in ymm1 subject to writemask k1.</td></tr>
<tr>
<td>EVEX.512.66.MAP6.W0  96  /r VFMADDSUB132PH  zmm1{k1}{z}, zmm2,  zmm3/m512/m16bcst  {er}</td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16</td>
<td>Multiply packed FP16 values from zmm1 and zmm3/m512/m16bcst, add/subtract elements in zmm2, and store the result in zmm1 subject to writemask k1.</td></tr>
<tr>
<td>EVEX.128.66.MAP6.W0  A6  /r VFMADDSUB213PH  xmm1{k1}{z}, xmm2,  xmm3/m128/m16bcst</td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16 AVX512VL</td>
<td>Multiply packed FP16 values from xmm1 and xmm2, add/subtract elements in xmm3/m128/m16bcst, and store the result in xmm1 subject to writemask k1.</td></tr>
<tr>
<td>EVEX.256.66.MAP6.W0  A6  /r VFMADDSUB213PH  ymm1{k1}{z}, ymm2,  ymm3/m256/m16bcst</td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16 AVX512VL</td>
<td>Multiply packed FP16 values from ymm1 and ymm2, add/subtract elements in ymm3/m256/m16bcst, and store the result in ymm1 subject to writemask k1.</td></tr>
<tr>
<td>EVEX.512.66.MAP6.W0  A6  /r VFMADDSUB213PH  zmm1{k1}{z}, zmm2,  zmm3/m512/m16bcst  {er}</td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16</td>
<td>Multiply packed FP16 values from zmm1 and zmm2, add/subtract elements in zmm3/m512/m16bcst, and store the result in zmm1 subject to writemask k1.</td></tr>
<tr>
<td>EVEX.128.66.MAP6.W0  B6  /r VFMADDSUB231PH  xmm1{k1}{z}, xmm2,  xmm3/m128/m16bcst</td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16 AVX512VL</td>
<td>Multiply packed FP16 values from xmm2 and xmm3/m128/m16bcst, add/subtract elements in xmm1, and store the result in xmm1 subject to writemask k1.</td></tr>
<tr>
<td>EVEX.256.66.MAP6.W0  B6  /r VFMADDSUB231PH  ymm1{k1}{z}, ymm2,  ymm3/m256/m16bcst</td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16 AVX512VL</td>
<td>Multiply packed FP16 values from ymm2 and ymm3/m256/m16bcst, add/subtract elements in ymm1, and store the result in ymm1 subject to writemask k1.</td></tr>
<tr>
<td>EVEX.512.66.MAP6.W0  B6  /r VFMADDSUB231PH  zmm1{k1}{z}, zmm2,  zmm3/m512/m16bcst  {er}</td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16</td>
<td>Multiply packed FP16 values from zmm2 and zmm3/m512/m16bcst, add/subtract elements in zmm1, and store the result in zmm1 subject to writemask k1.</td></tr></table>
<h3>Instruction Operand Encoding</h3>
<table>
<tr>
<th>Op/En</th>
<th>Tuple</th>
<th>Operand 1</th>
<th>Operand 2</th>
<th>Operand 3</th>
<th>Operand 4</th></tr>
<tr>
<td>A</td>
<td>Full</td>
<td>ModRM:reg (r, w)</td>
<td>VEX.vvvv (r)</td>
<td>ModRM:r/m (r)</td>
<td>N/A</td></tr></table>
<p><strong>Description</strong></p>
<p>This instruction performs a packed multiply-add (odd elements) or multiply-subtract (even elements) computation on FP16 values using three source operands and writes the results in the destination operand. The destination operand is also the first source operand. The notation’ “132”, “213” and “231” indicate the use of the operands in A * B ± C, where each digit corresponds to the operand number, with the destination being operand 1; see Table 5-7.</p>
<p>The destination elements are updated according to the writemask.</p>
<h3>Table 5-4.  VFMADDSUB[132,213,231]PH Notation for Odd and Even Elements</h3>
<table>
<tr>
<th>Notation</th>
<th>Odd Elements</th>
<th>Even Elements</th></tr>
<tr>
<td>132</td>
<td>dest = dest*src3+src2</td>
<td>dest = dest*src3-src2</td></tr>
<tr>
<td>231</td>
<td>dest = src2*src3+dest</td>
<td>dest = src2*src3-dest</td></tr>
<tr>
<td>213</td>
<td>dest = src2*dest+src3</td>
<td>dest = src2*dest-src3</td></tr></table>
<p><strong>Operation</strong></p>
<p><strong>VFMADDSUB132PH DEST, SRC2, SRC3 (EVEX encoded versions) when src3 operand is a register</strong></p>
<p>VL = 128, 256 or 512</p>
<p>KL := VL/16</p>
<p>IF (VL = 512) AND (EVEX.b = 1):</p>
<p>SET_RM(EVEX.RC)</p>
<p>ELSE</p>
<p>SET_RM(MXCSR.RC)</p>
<p>FOR j := 0 TO KL-1:</p>
<p>IF k1[j] OR *no writemask*:</p>
<p>IF *j is even*:</p>
<p>DEST.fp16[j] := RoundFPControl(DEST.fp16[j] * SRC3.fp16[j] - SRC2.fp16[j])</p>
<p>ELSE:</p>
<p>DEST.fp16[j] := RoundFPControl(DEST.fp16[j] * SRC3.fp16[j] + SRC2.fp16[j])</p>
<p>ELSE IF *zeroing*:</p>
<p>DEST.fp16[j] := 0</p>
<p>// else dest.fp16[j] remains unchanged</p>
<p>DEST[MAXVL-1:VL] := 0</p>
<p><strong>VFMADDSUB132PH DEST, SRC2, SRC3 (EVEX encoded versions) when src3 operand is a memory source</strong></p>
<p>VL = 128, 256 or 512</p>
<p>KL := VL/16</p>
<p>FOR j := 0 TO KL-1:</p>
<p>IF k1[j] OR *no writemask*:</p>
<p>IF EVEX.b = 1:</p>
<p>t3 := SRC3.fp16[0]</p>
<p>ELSE:</p>
<p>t3 := SRC3.fp16[j]</p>
<p>IF *j is even*:</p>
<p>DEST.fp16[j] := RoundFPControl(DEST.fp16[j] * t3 - SRC2.fp16[j])</p>
<p>ELSE:</p>
<p>DEST.fp16[j] := RoundFPControl(DEST.fp16[j] * t3 + SRC2.fp16[j])</p>
<p>ELSE IF *zeroing*:</p>
<p>DEST.fp16[j] := 0</p>
<p>// else dest.fp16[j] remains unchanged</p>
<p>DEST[MAXVL-1:VL] := 0</p>
<p><strong>VFMADDSUB213PH DEST, SRC2, SRC3 (EVEX encoded versions) when src3 operand is a register</strong></p>
<p>VL = 128, 256 or 512</p>
<p>KL := VL/16</p>
<p>IF (VL = 512) AND (EVEX.b = 1):</p>
<p>SET_RM(EVEX.RC)</p>
<p>ELSE</p>
<p>SET_RM(MXCSR.RC)</p>
<p>FOR j := 0 TO KL-1:</p>
<p>IF k1[j] OR *no writemask*:</p>
<p>IF *j is even*:</p>
<p>DEST.fp16[j] := RoundFPControl(SRC2.fp16[j]*DEST.fp16[j] - SRC3.fp16[j])</p>
<p>ELSE</p>
<p>DEST.fp16[j] := RoundFPControl(SRC2.fp16[j]*DEST.fp16[j] + SRC3.fp16[j])</p>
<p>ELSE IF *zeroing*:</p>
<p>DEST.fp16[j] := 0</p>
<p>// else dest.fp16[j] remains unchanged</p>
<p>DEST[MAXVL-1:VL] := 0</p>
<p><strong>VFMADDSUB213PH DEST, SRC2, SRC3 (EVEX encoded versions) when src3 operand is a memory source</strong></p>
<p>VL = 128, 256 or 512</p>
<p>KL := VL/16</p>
<p>FOR j := 0 TO KL-1:</p>
<p>IF k1[j] OR *no writemask*:</p>
<p>IF EVEX.b = 1:</p>
<p>t3 := SRC3.fp16[0]</p>
<p>ELSE:</p>
<p>t3 := SRC3.fp16[j]</p>
<p>IF *j is even*:</p>
<p>DEST.fp16[j] := RoundFPControl(SRC2.fp16[j] * DEST.fp16[j] - t3)</p>
<p>ELSE:</p>
<p>DEST.fp16[j] := RoundFPControl(SRC2.fp16[j] * DEST.fp16[j] + t3)</p>
<p>ELSE IF *zeroing*:</p>
<p>DEST.fp16[j] := 0</p>
<p>// else dest.fp16[j] remains unchanged</p>
<p>DEST[MAXVL-1:VL] := 0</p>
<p><strong>VFMADDSUB231PH DEST, SRC2, SRC3 (EVEX encoded versions) when src3 operand is a register</strong></p>
<p>VL = 128, 256 or 512</p>
<p>KL := VL/16</p>
<p>IF (VL = 512) AND (EVEX.b = 1):</p>
<p>SET_RM(EVEX.RC)</p>
<p>ELSE</p>
<p>SET_RM(MXCSR.RC)</p>
<p>FOR j := 0 TO KL-1:</p>
<p>IF k1[j] OR *no writemask*:</p>
<p>IF *j is even:</p>
<p>DEST.fp16[j] := RoundFPControl(SRC2.fp16[j] * SRC3.fp16[j] - DEST.fp16[j])</p>
<p>ELSE:</p>
<p>DEST.fp16[j] := RoundFPControl(SRC2.fp16[j] * SRC3.fp16[j] + DEST.fp16[j])</p>
<p>ELSE IF *zeroing*:</p>
<p>DEST.fp16[j] := 0</p>
<p>// else dest.fp16[j] remains unchanged</p>
<p>DEST[MAXVL-1:VL] := 0</p>
<p><strong>VFMADDSUB231PH DEST, SRC2, SRC3 (EVEX encoded versions) when src3 operand is a memory source</strong></p>
<p>VL = 128, 256 or 512</p>
<p>KL := VL/16</p>
<p>FOR j := 0 TO KL-1:</p>
<p>IF k1[j] OR *no writemask*:</p>
<p>IF EVEX.b = 1:</p>
<p>t3 := SRC3.fp16[0]</p>
<p>ELSE:</p>
<p>t3 := SRC3.fp16[j]</p>
<p>IF *j is even*:</p>
<p>DEST.fp16[j] := RoundFPControl(SRC2.fp16[j] * t3 - DEST.fp16[j])</p>
<p>ELSE:</p>
<p>DEST.fp16[j] := RoundFPControl(SRC2.fp16[j] * t3 + DEST.fp16[j])</p>
<p>ELSE IF *zeroing*:</p>
<p>DEST.fp16[j] := 0</p>
<p>// else dest.fp16[j] remains unchanged</p>
<p>DEST[MAXVL-1:VL] := 0</p>
<p><strong>Intel C/C++ Compiler Intrinsic Equivalent</strong></p>
<p>VFMADDSUB132PH, VFMADDSUB213PH, and VFMADDSUB231PH:</p>
<p>__m128h _mm_fmaddsub_ph (__m128h a, __m128h b, __m128h c);</p>
<p>__m128h _mm_mask_fmaddsub_ph (__m128h a, __mmask8 k, __m128h b, __m128h c);</p>
<p>__m128h _mm_mask3_fmaddsub_ph (__m128h a, __m128h b, __m128h c, __mmask8 k);</p>
<p>__m128h _mm_maskz_fmaddsub_ph (__mmask8 k, __m128h a, __m128h b, __m128h c);</p>
<p>__m256h _mm256_fmaddsub_ph (__m256h a, __m256h b, __m256h c);</p>
<p>__m256h _mm256_mask_fmaddsub_ph (__m256h a, __mmask16 k, __m256h b, __m256h c);</p>
<p>__m256h _mm256_mask3_fmaddsub_ph (__m256h a, __m256h b, __m256h c, __mmask16 k);</p>
<p>__m256h _mm256_maskz_fmaddsub_ph (__mmask16 k, __m256h a, __m256h b, __m256h c);</p>
<p>__m512h _mm512_fmaddsub_ph (__m512h a, __m512h b, __m512h c);</p>
<p>__m512h _mm512_mask_fmaddsub_ph (__m512h a, __mmask32 k, __m512h b, __m512h c);</p>
<p>__m512h _mm512_mask3_fmaddsub_ph (__m512h a, __m512h b, __m512h c, __mmask32 k);</p>
<p>__m512h _mm512_maskz_fmaddsub_ph (__mmask32 k, __m512h a, __m512h b, __m512h c);</p>
<p>__m512h _mm512_fmaddsub_round_ph (__m512h a, __m512h b, __m512h c, const int rounding);</p>
<p>__m512h _mm512_mask_fmaddsub_round_ph (__m512h a, __mmask32 k, __m512h b, __m512h c, const int rounding);</p>
<p>__m512h _mm512_mask3_fmaddsub_round_ph (__m512h a, __m512h b, __m512h c, __mmask32 k, const int rounding);</p>
<p>__m512h _mm512_maskz_fmaddsub_round_ph (__mmask32 k, __m512h a, __m512h b, __m512h c, const int rounding);</p>
<p><strong>SIMD Floating-Point Exceptions</strong></p>
<p>Invalid, Underflow, Overflow, Precision, Denormal.</p>
<p><strong>Other Exceptions</strong></p>
<p>EVEX-encoded instructions, see Table 2-46, “Type E2 Class Exception Conditions.”</p></div></body></html>