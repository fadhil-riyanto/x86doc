<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="style.css">
<script src="script.js"></script>
<title>VF[,N]MADD[132,213,231]PH - Fused Multiply-Add of Packed FP16 Values </title></head>
<body>
<div id="head">
<a href="index.html">x86doc</a> › VF[,N]MADD[132,213,231]PH - Fused Multiply-Add of Packed FP16 Values </div>
<div id="body">
<h1>VF[,N]MADD[132,213,231]PH—Fused Multiply-Add of Packed FP16 Values</h1>
<table>
<tr>
<th>Opcode/Instruction</th>
<th>Op/En</th>
<th>64/32 bit Mode Support</th>
<th>CPUID Feature Flag</th>
<th>Description</th></tr>
<tr>
<td>
<p>EVEX.128.66.MAP6.W0  98  /r</p>
<p>VFMADD132PH xmm1{k1}{z}, xmm2, xmm3/m128/m16bcst</p></td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16 AVX512VL</td>
<td>Multiply packed FP16 values from xmm1 and xmm3/m128/m16bcst, add to xmm2, and store the result in xmm1.</td></tr>
<tr>
<td>
<p>EVEX.256.66.MAP6.W0  98  /r</p>
<p>VFMADD132PH ymm1{k1}{z}, ymm2, ymm3/m256/m16bcst</p></td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16 AVX512VL</td>
<td>Multiply packed FP16 values from ymm1 and ymm3/m256/m16bcst, add to ymm2, and store the result in ymm1.</td></tr>
<tr>
<td>EVEX.512.66.MAP6.W0  98  /r VFMADD132PH  zmm1{k1}{z},  zmm2, zmm3/m512/m16bcst  {er}</td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16</td>
<td>Multiply packed FP16 values from zmm1 and zmm3/m512/m16bcst, add to zmm2, and store the result in zmm1.</td></tr>
<tr>
<td>
<p>EVEX.128.66.MAP6.W0  A8  /r</p>
<p>VFMADD213PH xmm1{k1}{z}, xmm2, xmm3/m128/m16bcst</p></td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16 AVX512VL</td>
<td>Multiply packed FP16 values from xmm1 and xmm2, add to xmm3/m128/m16bcst, and store the result in xmm1.</td></tr>
<tr>
<td>
<p>EVEX.256.66.MAP6.W0  A8  /r</p>
<p>VFMADD213PH ymm1{k1}{z}, ymm2, ymm3/m256/m16bcst</p></td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16 AVX512VL</td>
<td>Multiply packed FP16 values from ymm1 and ymm2, add to ymm3/m256/m16bcst, and store the result in ymm1.</td></tr>
<tr>
<td>EVEX.512.66.MAP6.W0  A8  /r VFMADD213PH  zmm1{k1}{z},  zmm2, zmm3/m512/m16bcst  {er}</td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16</td>
<td>Multiply packed FP16 values from zmm1 and zmm2, add to zmm3/m512/m16bcst, and store the result in zmm1.</td></tr>
<tr>
<td>
<p>EVEX.128.66.MAP6.W0  B8  /r</p>
<p>VFMADD231PH xmm1{k1}{z}, xmm2, xmm3/m128/m16bcst</p></td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16 AVX512VL</td>
<td>Multiply packed FP16 values from xmm2 and xmm3/m128/m16bcst, add to xmm1, and store the result in xmm1.</td></tr>
<tr>
<td>
<p>EVEX.256.66.MAP6.W0  B8  /r</p>
<p>VFMADD231PH ymm1{k1}{z}, ymm2, ymm3/m256/m16bcst</p></td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16 AVX512VL</td>
<td>Multiply packed FP16 values from ymm2 and ymm3/m256/m16bcst, add to ymm1, and store the result in ymm1.</td></tr>
<tr>
<td>EVEX.512.66.MAP6.W0  B8  /r VFMADD231PH  zmm1{k1}{z},  zmm2, zmm3/m512/m16bcst  {er}</td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16</td>
<td>Multiply packed FP16 values from zmm2 and zmm3/m512/m16bcst, add to zmm1, and store the result in zmm1.</td></tr>
<tr>
<td>EVEX.128.66.MAP6.W0  9C  /r VFNMADD132PH  xmm1{k1}{z}, xmm2,  xmm3/m128/m16bcst</td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16 AVX512VL</td>
<td>Multiply packed FP16 values from xmm1 and xmm3/m128/m16bcst, and negate the value. Add this value to xmm2, and store the result in xmm1.</td></tr>
<tr>
<td>EVEX.256.66.MAP6.W0  9C  /r VFNMADD132PH  ymm1{k1}{z}, ymm2,  ymm3/m256/m16bcst</td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16 AVX512VL</td>
<td>Multiply packed FP16 values from ymm1 and ymm3/m256/m16bcst, and negate the value. Add this value to ymm2, and store the result in ymm1.</td></tr>
<tr>
<td>EVEX.512.66.MAP6.W0  9C  /r VFNMADD132PH  zmm1{k1}{z}, zmm2,  zmm3/m512/m16bcst  {er}</td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16</td>
<td>Multiply packed FP16 values from zmm1 and zmm3/m512/m16bcst, and negate the value. Add this value to zmm2, and store the result in zmm1.</td></tr>
<tr>
<td>EVEX.128.66.MAP6.W0  AC  /r VFNMADD213PH  xmm1{k1}{z}, xmm2,  xmm3/m128/m16bcst</td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16 AVX512VL</td>
<td>Multiply packed FP16 values from xmm1 and xmm2, and negate the value. Add this value to xmm3/m128/m16bcst, and store the result in xmm1.</td></tr>
<tr>
<td>EVEX.256.66.MAP6.W0  AC  /r VFNMADD213PH  ymm1{k1}{z}, ymm2,  ymm3/m256/m16bcst</td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16 AVX512VL</td>
<td>Multiply packed FP16 values from ymm1 and ymm2, and negate the value. Add this value to ymm3/m256/m16bcst, and store the result in ymm1.</td></tr></table>
<p><strong>Opcode/</strong></p>
<p><strong>Op/</strong></p>
<p><strong>64/32</strong></p>
<p><strong>CPUID Feature</strong></p>
<p><strong>Description</strong></p>
<table>
<tr>
<th>Instruction</th>
<th>En</th>
<th>bit Mode Support</th>
<th>Flag</th>
<th></th></tr>
<tr>
<td>EVEX.512.66.MAP6.W0  AC  /r VFNMADD213PH  zmm1{k1}{z}, zmm2,  zmm3/m512/m16bcst  {er}</td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16</td>
<td>Multiply packed FP16 values from zmm1 and zmm2, and negate the value. Add this value to zmm3/m512/m16bcst, and store the result in zmm1.</td></tr>
<tr>
<td>EVEX.128.66.MAP6.W0  BC  /r VFNMADD231PH  xmm1{k1}{z}, xmm2,  xmm3/m128/m16bcst</td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16 AVX512VL</td>
<td>Multiply packed FP16 values from xmm2 and xmm3/m128/m16bcst, and negate the value. Add this value to xmm1, and store the result in xmm1.</td></tr>
<tr>
<td>EVEX.256.66.MAP6.W0  BC  /r VFNMADD231PH  ymm1{k1}{z}, ymm2,  ymm3/m256/m16bcst</td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16 AVX512VL</td>
<td>Multiply packed FP16 values from ymm2 and ymm3/m256/m16bcst, and negate the value. Add this value to ymm1, and store the result in ymm1.</td></tr>
<tr>
<td>EVEX.512.66.MAP6.W0  BC  /r VFNMADD231PH  zmm1{k1}{z}, zmm2,  zmm3/m512/m16bcst  {er}</td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16</td>
<td>Multiply packed FP16 values from zmm2 and zmm3/m512/m16bcst, and negate the value. Add this value to zmm1, and store the result in zmm1.</td></tr></table>
<h3>Instruction Operand Encoding</h3>
<table>
<tr>
<th>Op/En</th>
<th>Tuple</th>
<th>Operand 1</th>
<th>Operand 2</th>
<th>Operand 3</th>
<th>Operand 4</th></tr>
<tr>
<td>A</td>
<td>Full</td>
<td>ModRM:reg (r, w)</td>
<td>VEX.vvvv (r)</td>
<td>ModRM:r/m (r)</td>
<td>N/A</td></tr></table>
<p><strong>Description</strong></p>
<p>This instruction performs a packed multiply-add or negated multiply-add computation on FP16 values using three source operands and writes the results in the destination operand. The destination operand is also the first source operand. The “N” (negated) forms of this instruction add the negated infinite precision intermediate product to the corresponding remaining operand. The notation’ “132”, “213” and “231” indicate the use of the operands in ±A * B + C, where each digit corresponds to the operand number, with the destination being operand 1; see Table 5-2.</p>
<p>The destination elements are updated according to the writemask.</p>
<h3>Table 5-2.  VF[,N]MADD[132,213,231]PH Notation for Operands</h3>
<table>
<tr>
<th>Notation</th>
<th>
<p><strong>Operands</strong></p>
<p>dest = ± dest*src3+src2</p></th></tr>
<tr>
<td>132</td>
<td>dest = ± src2*src3+dest</td></tr>
<tr>
<td>231</td>
<td>dest = ± src2*dest+src3</td></tr>
<tr>
<td>213</td>
<td></td></tr></table>
<p><strong>Operation</strong></p>
<p><strong>VF[,N]MADD132PH DEST, SRC2, SRC3 (EVEX encoded versions) when src3 operand is a register</strong></p>
<p>VL = 128, 256 or 512</p>
<p>KL := VL/16</p>
<p>IF (VL = 512) AND (EVEX.b = 1):</p>
<p>SET_RM(EVEX.RC)</p>
<p>ELSE</p>
<p>SET_RM(MXCSR.RC)</p>
<p>FOR j := 0 TO KL-1:</p>
<p>IF k1[j] OR *no writemask*:</p>
<p>IF *negative form*:</p>
<p>DEST.fp16[j] := RoundFPControl(-DEST.fp16[j]*SRC3.fp16[j] + SRC2.fp16[j])</p>
<p>ELSE:</p>
<p>DEST.fp16[j] := RoundFPControl(DEST.fp16[j]*SRC3.fp16[j] + SRC2.fp16[j])</p>
<p>ELSE IF *zeroing*:</p>
<p>DEST.fp16[j] := 0</p>
<p>// else dest.fp16[j] remains unchanged</p>
<p>DEST[MAXVL-1:VL] := 0</p>
<p><strong>VF[,N]MADD132PH DEST, SRC2, SRC3 (EVEX encoded versions) when src3 operand is a memory source</strong></p>
<p>VL = 128, 256 or 512</p>
<p>KL := VL/16</p>
<p>FOR j := 0 TO KL-1:</p>
<p>IF k1[j] OR *no writemask*:</p>
<p>IF EVEX.b = 1:</p>
<p>t3 := SRC3.fp16[0]</p>
<p>ELSE:</p>
<p>t3 := SRC3.fp16[j]</p>
<p>IF *negative form*:</p>
<p>DEST.fp16[j] := RoundFPControl(-DEST.fp16[j] * t3 + SRC2.fp16[j])</p>
<p>ELSE:</p>
<p>DEST.fp16[j] := RoundFPControl(DEST.fp16[j] * t3 + SRC2.fp16[j])</p>
<p>ELSE IF *zeroing*:</p>
<p>DEST.fp16[j] := 0</p>
<p>// else dest.fp16[j] remains unchanged</p>
<p>DEST[MAXVL-1:VL] := 0</p>
<p><strong>VF[,N]MADD213PH DEST, SRC2, SRC3 (EVEX encoded versions) when src3 operand is a register</strong></p>
<p>VL = 128, 256 or 512</p>
<p>KL := VL/16</p>
<p>IF (VL = 512) AND (EVEX.b = 1):</p>
<p>SET_RM(EVEX.RC)</p>
<p>ELSE</p>
<p>SET_RM(MXCSR.RC)</p>
<p>FOR j := 0 TO KL-1:</p>
<p>IF k1[j] OR *no writemask*:</p>
<p>IF *negative form*:</p>
<p>DEST.fp16[j] := RoundFPControl(-SRC2.fp16[j]*DEST.fp16[j] + SRC3.fp16[j])</p>
<p>ELSE</p>
<p>DEST.fp16[j] := RoundFPControl(SRC2.fp16[j]*DEST.fp16[j] + SRC3.fp16[j])</p>
<p>ELSE IF *zeroing*:</p>
<p>DEST.fp16[j] := 0</p>
<p>// else dest.fp16[j] remains unchanged</p>
<p>DEST[MAXVL-1:VL] := 0</p>
<p><strong>VF[,N]MADD213PH DEST, SRC2, SRC3 (EVEX encoded versions) when src3 operand is a memory source</strong></p>
<p>VL = 128, 256 or 512</p>
<p>KL := VL/16</p>
<p>FOR j := 0 TO KL-1:</p>
<p>IF k1[j] OR *no writemask*:</p>
<p>IF EVEX.b = 1:</p>
<p>t3 := SRC3.fp16[0]</p>
<p>ELSE:</p>
<p>t3 := SRC3.fp16[j]</p>
<p>IF *negative form*:</p>
<p>DEST.fp16[j] := RoundFPControl(-SRC2.fp16[j] * DEST.fp16[j] + t3 )</p>
<p>ELSE:</p>
<p>DEST.fp16[j] := RoundFPControl(SRC2.fp16[j] * DEST.fp16[j] + t3 )</p>
<p>ELSE IF *zeroing*:</p>
<p>DEST.fp16[j] := 0</p>
<p>// else dest.fp16[j] remains unchanged</p>
<p>DEST[MAXVL-1:VL] := 0</p>
<p><strong>VF[,N]MADD231PH DEST, SRC2, SRC3 (EVEX encoded versions) when src3 operand is a register</strong></p>
<p>VL = 128, 256 or 512</p>
<p>KL := VL/16</p>
<p>IF (VL = 512) AND (EVEX.b = 1):</p>
<p>SET_RM(EVEX.RC)</p>
<p>ELSE</p>
<p>SET_RM(MXCSR.RC)</p>
<p>FOR j := 0 TO KL-1:</p>
<p>IF k1[j] OR *no writemask*:</p>
<p>IF *negative form:</p>
<p>DEST.fp16[j] := RoundFPControl(-SRC2.fp16[j]*SRC3.fp16[j] + DEST.fp16[j])</p>
<p>ELSE:</p>
<p>DEST.fp16[j] := RoundFPControl(SRC2.fp16[j]*SRC3.fp16[j] + DEST.fp16[j])</p>
<p>ELSE IF *zeroing*:</p>
<p>DEST.fp16[j] := 0</p>
<p>// else dest.fp16[j] remains unchanged</p>
<p>DEST[MAXVL-1:VL] := 0</p>
<p><strong>VF[,N]MADD231PH DEST, SRC2, SRC3 (EVEX encoded versions) when src3 operand is a memory source</strong></p>
<p>VL = 128, 256 or 512</p>
<p>KL := VL/16</p>
<p>FOR j := 0 TO KL-1:</p>
<p>IF k1[j] OR *no writemask*:</p>
<p>IF EVEX.b = 1:</p>
<p>t3 := SRC3.fp16[0]</p>
<p>ELSE:</p>
<p>t3 := SRC3.fp16[j]</p>
<p>IF *negative form*:</p>
<p>DEST.fp16[j] := RoundFPControl(-SRC2.fp16[j] * t3 + DEST.fp16[j] )</p>
<p>ELSE:</p>
<p>DEST.fp16[j] := RoundFPControl(SRC2.fp16[j] * t3 + DEST.fp16[j] )</p>
<p>ELSE IF *zeroing*:</p>
<p>DEST.fp16[j] := 0</p>
<p>// else dest.fp16[j] remains unchanged</p>
<p>DEST[MAXVL-1:VL] := 0</p>
<p><strong>Intel C/C++ Compiler Intrinsic Equivalent</strong></p>
<p>VFMADD132PH, VFMADD213PH , and VFMADD231PH:</p>
<p>__m128h _mm_fmadd_ph (__m128h a, __m128h b, __m128h c);</p>
<p>__m128h _mm_mask_fmadd_ph (__m128h a, __mmask8 k, __m128h b, __m128h c);</p>
<p>__m128h _mm_mask3_fmadd_ph (__m128h a, __m128h b, __m128h c, __mmask8 k);</p>
<p>__m128h _mm_maskz_fmadd_ph (__mmask8 k, __m128h a, __m128h b, __m128h c);</p>
<p>__m256h _mm256_fmadd_ph (__m256h a, __m256h b, __m256h c);</p>
<p>__m256h _mm256_mask_fmadd_ph (__m256h a, __mmask16 k, __m256h b, __m256h c);</p>
<p>__m256h _mm256_mask3_fmadd_ph (__m256h a, __m256h b, __m256h c, __mmask16 k);</p>
<p>__m256h _mm256_maskz_fmadd_ph (__mmask16 k, __m256h a, __m256h b, __m256h c);</p>
<p>__m512h _mm512_fmadd_ph (__m512h a, __m512h b, __m512h c);</p>
<p>__m512h _mm512_mask_fmadd_ph (__m512h a, __mmask32 k, __m512h b, __m512h c);</p>
<p>__m512h _mm512_mask3_fmadd_ph (__m512h a, __m512h b, __m512h c, __mmask32 k);</p>
<p>__m512h _mm512_maskz_fmadd_ph (__mmask32 k, __m512h a, __m512h b, __m512h c);</p>
<p>__m512h _mm512_fmadd_round_ph (__m512h a, __m512h b, __m512h c, const int rounding);</p>
<p>__m512h _mm512_mask_fmadd_round_ph (__m512h a, __mmask32 k, __m512h b, __m512h c, const int rounding);</p>
<p>__m512h _mm512_mask3_fmadd_round_ph (__m512h a, __m512h b, __m512h c, __mmask32 k, const int rounding);</p>
<p>__m512h _mm512_maskz_fmadd_round_ph (__mmask32 k, __m512h a, __m512h b, __m512h c, const int rounding);</p>
<p>VFNMADD132PH, VFNMADD213PH, and VFNMADD231PH:</p>
<p>__m128h _mm_fnmadd_ph (__m128h a, __m128h b, __m128h c);</p>
<p>__m128h _mm_mask_fnmadd_ph (__m128h a, __mmask8 k, __m128h b, __m128h c);</p>
<p>__m128h _mm_mask3_fnmadd_ph (__m128h a, __m128h b, __m128h c, __mmask8 k);</p>
<p>__m128h _mm_maskz_fnmadd_ph (__mmask8 k, __m128h a, __m128h b, __m128h c);</p>
<p>__m256h _mm256_fnmadd_ph (__m256h a, __m256h b, __m256h c);</p>
<p>__m256h _mm256_mask_fnmadd_ph (__m256h a, __mmask16 k, __m256h b, __m256h c);</p>
<p>__m256h _mm256_mask3_fnmadd_ph (__m256h a, __m256h b, __m256h c, __mmask16 k);</p>
<p>__m256h _mm256_maskz_fnmadd_ph (__mmask16 k, __m256h a, __m256h b, __m256h c);</p>
<p>__m512h _mm512_fnmadd_ph (__m512h a, __m512h b, __m512h c);</p>
<p>__m512h _mm512_mask_fnmadd_ph (__m512h a, __mmask32 k, __m512h b, __m512h c);</p>
<p>__m512h _mm512_mask3_fnmadd_ph (__m512h a, __m512h b, __m512h c, __mmask32 k);</p>
<p>__m512h _mm512_maskz_fnmadd_ph (__mmask32 k, __m512h a, __m512h b, __m512h c);</p>
<p>__m512h _mm512_fnmadd_round_ph (__m512h a, __m512h b, __m512h c, const int rounding);</p>
<p>__m512h _mm512_mask_fnmadd_round_ph (__m512h a, __mmask32 k, __m512h b, __m512h c, const int rounding);</p>
<p>__m512h _mm512_mask3_fnmadd_round_ph (__m512h a, __m512h b, __m512h c, __mmask32 k, const int rounding);</p>
<p>__m512h _mm512_maskz_fnmadd_round_ph (__mmask32 k, __m512h a, __m512h b, __m512h c, const int rounding);</p>
<p><strong>SIMD Floating-Point Exceptions</strong></p>
<p>Invalid, Underflow, Overflow, Precision, Denormal</p>
<p><strong>Other Exceptions</strong></p>
<p>EVEX-encoded instructions, see Table 2-46, “Type E2 Class Exception Conditions.”</p></div></body></html>