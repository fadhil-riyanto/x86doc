<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="style.css">
<script src="script.js"></script>
<title>AAD - ASCII Adjust AX Before Division </title></head>
<body>
<div id="head">
<a href="index.html">x86doc</a> › AAD - ASCII Adjust AX Before Division </div>
<div id="body">
<h1>AAD—ASCII Adjust AX Before Division</h1>
<table>
<tr>
<th>Opcode</th>
<th>Instruction</th>
<th>Op/En</th>
<th>64-bit Mode</th>
<th>Compat/Leg Mode</th>
<th>Description</th></tr>
<tr>
<td>D5 0A</td>
<td>AAD</td>
<td>ZO</td>
<td>Invalid</td>
<td>Valid</td>
<td>ASCII adjust AX before division.</td></tr>
<tr>
<td>D5 ib</td>
<td>AAD imm8</td>
<td>ZO</td>
<td>Invalid</td>
<td>Valid</td>
<td>Adjust AX before division to number base imm8.</td></tr></table>
<h3>Instruction Operand Encoding</h3>
<table>
<tr>
<th>Op/En</th>
<th>Operand 1</th>
<th>Operand 2</th>
<th>Operand 3</th>
<th>Operand 4</th></tr>
<tr>
<td>ZO</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td></tr></table>
<h2>Description</h2>
<p>Adjusts two unpacked BCD digits (the least-significant digit in the AL register and the most-significant digit in the AH register) so that a division operation performed on the result will yield a correct unpacked BCD value. The AAD instruction is only useful when it precedes a DIV instruction that divides (binary division) the adjusted value in the AX register by an unpacked BCD value.</p>
<p>The AAD instruction sets the value in the AL register to (AL + (10 * AH)), and then clears the AH register to 00H. The value in the AX register is then equal to the binary equivalent of the original unpacked two-digit (base 10) number in registers AH and AL.</p>
<p>The generalized version of this instruction allows adjustment of two unpacked digits of any number base (see the “Operation” section below), by setting the <em>imm8</em> byte to the selected number base (for example, 08H for octal, 0AH for decimal, or 0CH for base 12 numbers). The AAD mnemonic is interpreted by all assemblers to mean adjust ASCII (base 10) values. To adjust values in another number base, the instruction must be hand coded in machine code (D5 <em>imm8</em>).</p>
<p>This instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.</p>
<h2>Operation</h2>
<pre>IF 64-Bit Mode
    THEN
         #UD;
    ELSE
         tempAL := AL;
         tempAH := AH;
         AL := (tempAL + (tempAH ∗ <em>imm8</em>)) AND FFH; (* <em>imm8</em> is set to 0AH for the AAD mnemonic.*)
         AH := 0;
FI;
The immediate value (<em>imm8</em>) is taken from the second byte of the instruction.</pre>
<h2>Flags Affected</h2>
<p>The SF, ZF, and PF flags are set according to the resulting binary value in the AL register; the OF, AF, and CF flags are undefined.</p>
<h2>Protected Mode Exceptions</h2>
<table class="exception-table">
<tr>
<td>#UD</td>
<td>If the LOCK prefix is used.</td></tr></table>
<h2>Real-Address Mode Exceptions</h2>
<p>Same exceptions as protected mode.</p>
<h2>Virtual-8086 Mode Exceptions</h2>
<p>Same exceptions as protected mode.</p>
<h2>Compatibility Mode Exceptions</h2>
<p>Same exceptions as protected mode.</p>
<h2>64-Bit Mode Exceptions</h2>
<table class="exception-table">
<tr>
<td>#UD</td>
<td>If in 64-bit mode.</td></tr></table></div></body></html>