<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="style.css">
<script src="script.js"></script>
<title>MOVD/MOVQ - Move Doubleword/Move Quadword </title></head>
<body>
<div id="head">
<a href="index.html">x86doc</a> › MOVD/MOVQ - Move Doubleword/Move Quadword </div>
<div id="body">
<h1>MOVD/MOVQ—Move Doubleword/Move Quadword</h1>
<table>
<tr>
<th>Opcode/Instruction</th>
<th>Op/ En</th>
<th>64/32-bit Mode</th>
<th>CPUID Feature Flag</th>
<th>Description</th></tr>
<tr>
<td>
<p>NP 0F 6E /r</p>
<p>MOVD mm, r/m32</p></td>
<td>A</td>
<td>V/V</td>
<td>MMX</td>
<td>Move doubleword from r/m32 to mm.</td></tr>
<tr>
<td>
<p>NP REX.W + 0F 6E /r</p>
<p>MOVQ mm, r/m64</p></td>
<td>A</td>
<td>V/N.E.</td>
<td>MMX</td>
<td>Move quadword from r/m64 to mm.</td></tr>
<tr>
<td>
<p>NP 0F 7E /r</p>
<p>MOVD r/m32, mm</p></td>
<td>B</td>
<td>V/V</td>
<td>MMX</td>
<td>Move doubleword from mm to r/m32.</td></tr>
<tr>
<td>
<p>NP REX.W + 0F 7E /r</p>
<p>MOVQ r/m64, mm</p></td>
<td>B</td>
<td>V/N.E.</td>
<td>MMX</td>
<td>Move quadword from mm to r/m64.</td></tr>
<tr>
<td>
<p>66 0F 6E /r</p>
<p>MOVD xmm, r/m32</p></td>
<td>A</td>
<td>V/V</td>
<td>SSE2</td>
<td>Move doubleword from r/m32 to xmm.</td></tr>
<tr>
<td>
<p>66 REX.W 0F 6E /r</p>
<p>MOVQ xmm, r/m64</p></td>
<td>A</td>
<td>V/N.E.</td>
<td>SSE2</td>
<td>Move quadword from r/m64 to xmm.</td></tr>
<tr>
<td>
<p>66 0F 7E /r</p>
<p>MOVD r/m32, xmm</p></td>
<td>B</td>
<td>V/V</td>
<td>SSE2</td>
<td>Move doubleword from xmm register to r/m32.</td></tr>
<tr>
<td>
<p> 66 REX.W 0F 7E /r</p>
<p>MOVQ r/m64, xmm</p></td>
<td>B</td>
<td>V/N.E.</td>
<td>SSE2</td>
<td>Move quadword from xmm register to r/m64.</td></tr>
<tr>
<td>
<p>VEX.128.66.0F.W0 6E /</p>
<p>VMOVD xmm1, r32/m32</p></td>
<td>A</td>
<td>V/V</td>
<td>AVX</td>
<td>Move doubleword from r/m32 to xmm1.</td></tr>
<tr>
<td>
<p>VEX.128.66.0F.W1 6E /r</p>
<p>VMOVQ xmm1, r64/m64</p></td>
<td>A</td>
<td>V/N.E<sup>1</sup>.</td>
<td>AVX</td>
<td>Move quadword from r/m64 to xmm1.</td></tr>
<tr>
<td>
<p>VEX.128.66.0F.W0 7E /r</p>
<p>VMOVD r32/m32, xmm1</p></td>
<td>B</td>
<td>V/V</td>
<td>AVX</td>
<td>Move doubleword from xmm1 register to r/m32.</td></tr>
<tr>
<td>
<p>VEX.128.66.0F.W1 7E /r</p>
<p>VMOVQ r64/m64, xmm1</p></td>
<td>B</td>
<td>V/N.E<sup>1</sup>.</td>
<td>AVX</td>
<td>Move quadword from xmm1 register to r/m64.</td></tr>
<tr>
<td>EVEX.128.66.0F.W0 6E /r VMOVD xmm1, r32/m32</td>
<td>C</td>
<td>V/V</td>
<td>AVX512F</td>
<td>Move doubleword from r/m32 to xmm1.</td></tr>
<tr>
<td>EVEX.128.66.0F.W1 6E /r VMOVQ xmm1, r64/m64</td>
<td>C</td>
<td>V/N.E.<sup>1</sup></td>
<td>AVX512F</td>
<td>Move quadword from r/m64 to xmm1.</td></tr>
<tr>
<td>EVEX.128.66.0F.W0 7E /r VMOVD r32/m32, xmm1</td>
<td>D</td>
<td>V/V</td>
<td>AVX512F</td>
<td>Move doubleword from xmm1 register to r/m32.</td></tr>
<tr>
<td>EVEX.128.66.0F.W1 7E /r VMOVQ r64/m64, xmm1</td>
<td>D</td>
<td>V/N.E.<sup>1</sup></td>
<td>AVX512F</td>
<td>Move quadword from xmm1 register to r/m64.</td></tr></table>
<p><strong>NOTES:</strong></p>
<p>1. For this specific instruction, VEX.W/EVEX.W in non-64 bit is ignored; the instruction behaves as if the W0 version is used.</p>
<h3>Instruction Operand Encoding</h3>
<table>
<tr>
<th>Op/En</th>
<th>Tuple Type</th>
<th>Operand 1</th>
<th>Operand 2</th>
<th>Operand 3</th>
<th>Operand 4</th></tr>
<tr>
<td>A</td>
<td>N/A</td>
<td>ModRM:reg (w)</td>
<td>ModRM:r/m (r)</td>
<td>N/A</td>
<td>N/A</td></tr>
<tr>
<td>B</td>
<td>N/A</td>
<td>ModRM:r/m (w)</td>
<td>ModRM:reg (r)</td>
<td>N/A</td>
<td>N/A</td></tr>
<tr>
<td>C</td>
<td>Tuple1 Scalar</td>
<td>ModRM:reg (w)</td>
<td>ModRM:r/m (r)</td>
<td>N/A</td>
<td>N/A</td></tr>
<tr>
<td>D</td>
<td>Tuple1 Scalar</td>
<td>ModRM:r/m (w)</td>
<td>ModRM:reg (r)</td>
<td>N/A</td>
<td>N/A</td></tr></table>
<h2>Description</h2>
<p>Copies a doubleword from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be general-purpose registers, MMX technology registers, XMM registers, or 32-bit memory locations. This instruction can be used to move a doubleword to and from the low doubleword of an MMX technology register and a general-purpose register or a 32-bit memory location, or to and from the low doubleword of an XMM register and a general-purpose register or a 32-bit memory location. The instruction cannot be used to transfer data between MMX technology registers, between XMM registers, between general-purpose registers, or between memory locations.</p>
<p>When the destination operand is an MMX technology register, the source operand is written to the low doubleword of the register, and the register is zero-extended to 64 bits. When the destination operand is an XMM register, the source operand is written to the low doubleword of the register, and the register is zero-extended to 128 bits.</p>
<p>In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to addi-tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p>
<p>MOVD/Q with XMM destination:</p>
<p>Moves a dword/qword integer from the source operand and stores it in the low 32/64-bits of the destination XMM register. The upper bits of the destination are zeroed. The source operand can be a 32/64-bit register or 32/64-bit memory location.</p>
<p>128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged. Qword operation requires the use of REX.W=1.</p>
<p>VEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed. Qword operation requires the use of VEX.W=1.</p>
<p>EVEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed. Qword operation requires the use of EVEX.W=1.</p>
<p>MOVD/Q with 32/64 reg/mem destination:</p>
<p>Stores the low dword/qword of the source XMM register to 32/64-bit memory location or general-purpose register. Qword operation requires the use of REX.W=1, VEX.W=1, or EVEX.W=1.</p>
<p>Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.</p>
<p>If VMOVD or VMOVQ is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.</p>
<h2>Operation</h2>
<p><strong>MOVD (When Destination Operand is an MMX Technology Register)</strong></p>
<pre>    DEST[31:0] := SRC;
    DEST[63:32] := 00000000H;</pre>
<p><strong>MOVD (When Destination Operand is an XMM Register)</strong></p>
<pre>    DEST[31:0] := SRC;
    DEST[127:32] := 000000000000000000000000H;
    DEST[MAXVL-1:128] (Unmodified)</pre>
<p><strong>MOVD (When Source Operand is an MMX Technology or XMM Register)</strong></p>
<pre>    DEST := SRC[31:0];</pre>
<p><strong>VMOVD (VEX-Encoded Version when Destination is an XMM Register)</strong></p>
<pre>    DEST[31:0] := SRC[31:0]
    DEST[MAXVL-1:32] := 0</pre>
<p><strong>MOVQ (When Destination Operand is an XMM Register)</strong></p>
<pre>    DEST[63:0] := SRC[63:0];
    DEST[127:64] := 0000000000000000H;
    DEST[MAXVL-1:128] (Unmodified)</pre>
<p><strong>MOVQ (When Destination Operand is r/m64)</strong></p>
<pre>    DEST[63:0] := SRC[63:0];</pre>
<p><strong>MOVQ (When Source Operand is an XMM Register or r/m64)</strong></p>
<pre>    DEST := SRC[63:0];</pre>
<p><strong>VMOVQ (VEX-Encoded Version When Destination is an XMM Register)</strong></p>
<pre>    DEST[63:0] := SRC[63:0]
    DEST[MAXVL-1:64] := 0</pre>
<p><strong>VMOVD (EVEX-Encoded Version When Destination is an XMM Register)</strong></p>
<pre>DEST[31:0] := SRC[31:0]
DEST[MAXVL-1:32] := 0</pre>
<p><strong>VMOVQ (EVEX-Encoded Version When Destination is an XMM Register)</strong></p>
<pre>DEST[63:0] := SRC[63:0]
DEST[MAXVL-1:64] := 0</pre>
<h2>Intel C/C++ Compiler Intrinsic Equivalent</h2>
<p>MOVD __m64 _mm_cvtsi32_si64 (int i )</p>
<p>MOVD int _mm_cvtsi64_si32 ( __m64m )</p>
<p>MOVD __m128i _mm_cvtsi32_si128 (int a)</p>
<p>MOVD int _mm_cvtsi128_si32 ( __m128i a)</p>
<p>MOVQ __int64 _mm_cvtsi128_si64(__m128i);</p>
<p>MOVQ __m128i _mm_cvtsi64_si128(__int64);</p>
<p>VMOVD __m128i _mm_cvtsi32_si128( int);</p>
<p>VMOVD int _mm_cvtsi128_si32( __m128i );</p>
<p>VMOVQ __m128i _mm_cvtsi64_si128 (__int64);</p>
<p>VMOVQ __int64 _mm_cvtsi128_si64(__m128i );</p>
<p>VMOVQ __m128i _mm_loadl_epi64( __m128i * s);</p>
<p>VMOVQ void _mm_storel_epi64( __m128i * d, __m128i s);</p>
<h2>Flags Affected</h2>
<p>None.</p>
<h2>SIMD Floating-Point Exceptions</h2>
<p>None.</p>
<h2>Other Exceptions</h2>
<p>Non-EVEX-encoded instruction, see Table 2-22, “Type 5 Class Exception Conditions.”</p>
<p>EVEX-encoded instruction, see Table 2-57, “Type E9NF Class Exception Conditions.”</p>
<p>Additionally:</p>
<table class="exception-table">
<tr>
<td>#UD</td>
<td>
<p>If VEX.L = 1.</p>
<p>If VEX.vvvv != 1111B or EVEX.vvvv != 1111B.</p></td></tr></table></div></body></html>