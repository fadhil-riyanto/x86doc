<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="style.css">
<script src="script.js"></script>
<title>VPERMT2W/D/Q/PS/PD - Full Permute From Two Tables Overwriting One Table </title></head>
<body>
<div id="head">
<a href="index.html">x86doc</a> › VPERMT2W/D/Q/PS/PD - Full Permute From Two Tables Overwriting One Table </div>
<div id="body">
<h1>VPERMT2W/D/Q/PS/PD—Full Permute From Two Tables Overwriting One Table</h1>
<table>
<tr>
<th>Opcode/Instruction</th>
<th>Op /En</th>
<th>64/32 bit Mode Support</th>
<th>CPUID Feature Flag</th>
<th>Description</th></tr>
<tr>
<td>EVEX.128.66.0F38.W1 7D /r VPERMT2W xmm1 {k1}{z}, xmm2, xmm3/m128</td>
<td>A</td>
<td>V/V</td>
<td>AVX512VL AVX512BW</td>
<td>Permute word integers from two tables in xmm3/m128 and xmm1 using indexes in xmm2 and store the result in xmm1 using writemask k1.</td></tr>
<tr>
<td>EVEX.256.66.0F38.W1 7D /r VPERMT2W ymm1 {k1}{z}, ymm2, ymm3/m256</td>
<td>A</td>
<td>V/V</td>
<td>AVX512VL AVX512BW</td>
<td>Permute word integers from two tables in ymm3/m256 and ymm1 using indexes in ymm2 and store the result in ymm1 using writemask k1.</td></tr>
<tr>
<td>EVEX.512.66.0F38.W1 7D /r VPERMT2W zmm1 {k1}{z}, zmm2, zmm3/m512</td>
<td>A</td>
<td>V/V</td>
<td>AVX512BW</td>
<td>Permute word integers from two tables in zmm3/m512 and zmm1 using indexes in zmm2 and store the result in zmm1 using writemask k1.</td></tr>
<tr>
<td>EVEX.128.66.0F38.W0 7E /r VPERMT2D xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</td>
<td>B</td>
<td>V/V</td>
<td>AVX512VL AVX512F</td>
<td>Permute double-words from two tables in xmm3/m128/m32bcst and xmm1 using indexes in xmm2 and store the result in xmm1 using writemask k1.</td></tr>
<tr>
<td>EVEX.256.66.0F38.W0 7E /r VPERMT2D ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</td>
<td>B</td>
<td>V/V</td>
<td>AVX512VL AVX512F</td>
<td>Permute double-words from two tables in ymm3/m256/m32bcst and ymm1 using indexes in ymm2 and store the result in ymm1 using writemask k1.</td></tr>
<tr>
<td>EVEX.512.66.0F38.W0 7E /r VPERMT2D zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</td>
<td>B</td>
<td>V/V</td>
<td>AVX512F</td>
<td>Permute double-words from two tables in zmm3/m512/m32bcst and zmm1 using indices in zmm2 and store the result in zmm1 using writemask k1.</td></tr>
<tr>
<td>EVEX.128.66.0F38.W1 7E /r VPERMT2Q xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</td>
<td>B</td>
<td>V/V</td>
<td>AVX512VL AVX512F</td>
<td>Permute quad-words from two tables in xmm3/m128/m64bcst and xmm1 using indexes in xmm2 and store the result in xmm1 using writemask k1.</td></tr>
<tr>
<td>EVEX.256.66.0F38.W1 7E /r VPERMT2Q ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</td>
<td>B</td>
<td>V/V</td>
<td>AVX512VL AVX512F</td>
<td>Permute quad-words from two tables in ymm3/m256/m64bcst and ymm1 using indexes in ymm2 and store the result in ymm1 using writemask k1.</td></tr>
<tr>
<td>EVEX.512.66.0F38.W1 7E /r VPERMT2Q zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</td>
<td>B</td>
<td>V/V</td>
<td>AVX512F</td>
<td>Permute quad-words from two tables in zmm3/m512/m64bcst and zmm1 using indices in zmm2 and store the result in zmm1 using writemask k1.</td></tr>
<tr>
<td>EVEX.128.66.0F38.W0 7F /r VPERMT2PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</td>
<td>B</td>
<td>V/V</td>
<td>AVX512VL AVX512F</td>
<td>Permute single-precision floating-point values from two tables in xmm3/m128/m32bcst and xmm1 using indexes in xmm2 and store the result in xmm1 using writemask k1.</td></tr>
<tr>
<td>EVEX.256.66.0F38.W0 7F /r VPERMT2PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</td>
<td>B</td>
<td>V/V</td>
<td>AVX512VL AVX512F</td>
<td>Permute single-precision floating-point values from two tables in ymm3/m256/m32bcst and ymm1 using indexes in ymm2 and store the result in ymm1 using writemask k1.</td></tr>
<tr>
<td>EVEX.512.66.0F38.W0 7F /r VPERMT2PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</td>
<td>B</td>
<td>V/V</td>
<td>AVX512F</td>
<td>Permute single-precision floating-point values from two tables in zmm3/m512/m32bcst and zmm1 using indices in zmm2 and store the result in zmm1 using writemask k1.</td></tr>
<tr>
<td>EVEX.128.66.0F38.W1 7F /r VPERMT2PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</td>
<td>B</td>
<td>V/V</td>
<td>AVX512VL AVX512F</td>
<td>Permute double precision floating-point values from two tables in xmm3/m128/m64bcst and xmm1 using indexes in xmm2 and store the result in xmm1 using writemask k1.</td></tr>
<tr>
<td>EVEX.256.66.0F38.W1 7F /r VPERMT2PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</td>
<td>B</td>
<td>V/V</td>
<td>AVX512VL AVX512F</td>
<td>Permute double precision floating-point values from two tables in ymm3/m256/m64bcst and ymm1 using indexes in ymm2 and store the result in ymm1 using writemask k1.</td></tr>
<tr>
<td>EVEX.512.66.0F38.W1 7F /r VPERMT2PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</td>
<td>B</td>
<td>V/V</td>
<td>AVX512F</td>
<td>Permute double precision floating-point values from two tables in zmm3/m512/m64bcst and zmm1 using indices in zmm2 and store the result in zmm1 using writemask k1.</td></tr></table>
<h3>Instruction Operand Encoding</h3>
<table>
<tr>
<th>Op/En</th>
<th>Tuple Type</th>
<th>Operand 1</th>
<th>Operand 2</th>
<th>Operand 3</th>
<th>Operand 4</th></tr>
<tr>
<td>A</td>
<td>Full Mem</td>
<td>ModRM:reg (r,w)</td>
<td>EVEX.vvvv (r)</td>
<td>ModRM:r/m (r)</td>
<td>N/A</td></tr>
<tr>
<td>B</td>
<td>Full</td>
<td>ModRM:reg (r, w)</td>
<td>EVEX.vvvv (r)</td>
<td>ModRM:r/m (r)</td>
<td>N/A</td></tr></table>
<p><strong>Description</strong></p>
<p>Permutes 16-bit/32-bit/64-bit values in the first operand and the third operand (the second source operand) using indices in the second operand (the first source operand) to select elements from the first and third operands. The selected elements are written to the destination operand (the first operand) according to the writemask k1.</p>
<p>The first and second operands are ZMM/YMM/XMM registers. The second operand contains input indices to select elements from the two input tables in the 1st and 3rd operands. The first operand is also the destination of the result.</p>
<p>D/Q/PS/PD element versions: The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. Broadcast from the low 32/64-bit memory location is performed if EVEX.b and the id bit for table selection are set (selecting table_2).</p>
<p>Dword/PS versions: The id bit for table selection is bit 4/3/2, depending on VL=512, 256, 128. Bits [3:0]/[2:0]/[1:0] of each element in the input index vector select an element within the two source operands, If the id bit is 0, table_1 (the first source) is selected; otherwise the second source operand is selected.</p>
<p>Qword/PD versions: The id bit for table selection is bit 3/2/1, and bits [2:0]/[1:0] /bit 0 selects element within each input table.</p>
<p>Word element versions: The second source operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The id bit for table selection is bit 5/4/3, and bits [4:0]/[3:0]/[2:0] selects element within each input table.</p>
<p>Note that these instructions permit a 16-bit/32-bit/64-bit value in the source operands to be copied to more than one location in the destination operand. Note also that in this case, the same index can be reused for example for a second iteration, while the table elements being permuted are overwritten.</p>
<p>Bits (MAXVL-1:256/128) of the destination are zeroed for VL=256,128.</p>
<p><strong>Operation</strong></p>
<p><strong>VPERMT2W (EVEX encoded versions)</strong></p>
<p>(KL, VL) = (8, 128), (16, 256), (32, 512)</p>
<p>IF VL = 128</p>
<p>id := 2</p>
<p>FI;</p>
<p>IF VL = 256</p>
<p>id := 3</p>
<p>FI;</p>
<p>IF VL = 512</p>
<p>id := 4</p>
<p>FI;</p>
<p>TMP_DEST := DEST</p>
<p>FOR j := 0 TO KL-1</p>
<p>i := j * 16</p>
<p>off := 16*SRC1[i+id:i]</p>
<p>IF k1[j] OR *no writemask*</p>
<p>THEN</p>
<p>DEST[i+15:i]=SRC1[i+id+1] ? SRC2[off+15:off]</p>
<p>       : TMP_DEST[off+15:off]</p>
<p>ELSE</p>
<p>IF *merging-masking*</p>
<p>; merging-masking</p>
<p>THEN *DEST[i+15:i] remains unchanged*</p>
<p>ELSE</p>
<p>; zeroing-masking</p>
<p>DEST[i+15:i] := 0</p>
<p>FI</p>
<p>FI;</p>
<p>ENDFOR</p>
<p>DEST[MAXVL-1:VL] := 0</p>
<p><strong>VPERMT2D/VPERMT2PS (EVEX encoded versions)</strong></p>
<p>(KL, VL) = (4, 128), (8, 256), (16, 512)</p>
<p>IF VL = 128</p>
<p>id := 1</p>
<p>FI;</p>
<p>IF VL = 256</p>
<p>id := 2</p>
<p>FI;</p>
<p>IF VL = 512</p>
<p>id := 3</p>
<p>FI;</p>
<p>TMP_DEST := DEST</p>
<p>FOR j := 0 TO KL-1</p>
<p>i := j * 32</p>
<p>off := 32*SRC1[i+id:i]</p>
<p>IF k1[j] OR *no writemask*</p>
<p>THEN</p>
<p>IF (EVEX.b = 1) AND (SRC2 *is memory*)</p>
<p>THEN</p>
<p>DEST[i+31:i] := SRC1[i+id+1] ? SRC2[31:0]</p>
<p>       : TMP_DEST[off+31:off]</p>
<p>ELSE</p>
<p>DEST[i+31:i] := SRC1[i+id+1] ? SRC2[off+31:off]</p>
<p>       : TMP_DEST[off+31:off]</p>
<p>FI</p>
<p>ELSE</p>
<p>IF *merging-masking*</p>
<p>; merging-masking</p>
<p>THEN *DEST[i+31:i] remains unchanged*</p>
<p>ELSE</p>
<p>; zeroing-masking</p>
<p>DEST[i+31:i] := 0</p>
<p>FI</p>
<p>FI;</p>
<p>ENDFOR</p>
<p>DEST[MAXVL-1:VL] := 0</p>
<p><strong>VPERMT2Q/VPERMT2PD (EVEX encoded versions)</strong></p>
<p>(KL, VL) = (2, 128), (4, 256), (8 512)</p>
<p>IF VL = 128</p>
<p>id := 0</p>
<p>FI;</p>
<p>IF VL = 256</p>
<p>id := 1</p>
<p>FI;</p>
<p>IF VL = 512</p>
<p>id := 2</p>
<p>FI;</p>
<p>TMP_DEST:= DEST</p>
<p>FOR j := 0 TO KL-1</p>
<p>i := j * 64</p>
<p>off := 64*SRC1[i+id:i]</p>
<p>IF k1[j] OR *no writemask*</p>
<p>THEN</p>
<p>IF (EVEX.b = 1) AND (SRC2 *is memory*)</p>
<p>THEN</p>
<p>DEST[i+63:i] := SRC1[i+id+1] ? SRC2[63:0]</p>
<p>       : TMP_DEST[off+63:off]</p>
<p>ELSE</p>
<p>DEST[i+63:i] := SRC1[i+id+1] ? SRC2[off+63:off]</p>
<p>       : TMP_DEST[off+63:off]</p>
<p>FI</p>
<p>ELSE</p>
<p>IF *merging-masking*</p>
<p>; merging-masking</p>
<p>THEN *DEST[i+63:i] remains unchanged*</p>
<p>ELSE</p>
<p>; zeroing-masking</p>
<p>DEST[i+63:i] := 0</p>
<p>FI</p>
<p>FI;</p>
<p>ENDFOR</p>
<p>DEST[MAXVL-1:VL] := 0</p>
<p><strong>Intel C/C++ Compiler Intrinsic Equivalent</strong></p>
<p>VPERMT2D __m512i _mm512_permutex2var_epi32(__m512i a, __m512i idx, __m512i b);</p>
<p>VPERMT2D __m512i _mm512_mask_permutex2var_epi32(__m512i a, __mmask16 k, __m512i idx, __m512i b);</p>
<p>VPERMT2D __m512i _mm512_mask2_permutex2var_epi32(__m512i a, __m512i idx, __mmask16 k, __m512i b);</p>
<p>VPERMT2D __m512i _mm512_maskz_permutex2var_epi32(__mmask16 k, __m512i a, __m512i idx, __m512i b);</p>
<p>VPERMT2D __m256i _mm256_permutex2var_epi32(__m256i a, __m256i idx, __m256i b);</p>
<p>VPERMT2D __m256i _mm256_mask_permutex2var_epi32(__m256i a, __mmask8 k, __m256i idx, __m256i b);</p>
<p>VPERMT2D __m256i _mm256_mask2_permutex2var_epi32(__m256i a, __m256i idx, __mmask8 k, __m256i b);</p>
<p>VPERMT2D __m256i _mm256_maskz_permutex2var_epi32(__mmask8 k, __m256i a, __m256i idx, __m256i b);</p>
<p>VPERMT2D __m128i _mm_permutex2var_epi32(__m128i a, __m128i idx, __m128i b);</p>
<p>VPERMT2D __m128i _mm_mask_permutex2var_epi32(__m128i a, __mmask8 k, __m128i idx, __m128i b);</p>
<p>VPERMT2D __m128i _mm_mask2_permutex2var_epi32(__m128i a, __m128i idx, __mmask8 k, __m128i b);</p>
<p>VPERMT2D __m128i _mm_maskz_permutex2var_epi32(__mmask8 k, __m128i a, __m128i idx, __m128i b);</p>
<p>VPERMT2PD __m512d _mm512_permutex2var_pd(__m512d a, __m512i idx, __m512d b);</p>
<p>VPERMT2PD __m512d _mm512_mask_permutex2var_pd(__m512d a, __mmask8 k, __m512i idx, __m512d b);</p>
<p>VPERMT2PD __m512d _mm512_mask2_permutex2var_pd(__m512d a, __m512i idx, __mmask8 k, __m512d b);</p>
<p>VPERMT2PD __m512d _mm512_maskz_permutex2var_pd(__mmask8 k, __m512d a, __m512i idx, __m512d b);</p>
<p>VPERMT2PD __m256d _mm256_permutex2var_pd(__m256d a, __m256i idx, __m256d b);</p>
<p>VPERMT2PD __m256d _mm256_mask_permutex2var_pd(__m256d a, __mmask8 k, __m256i idx, __m256d b);</p>
<p>VPERMT2PD __m256d _mm256_mask2_permutex2var_pd(__m256d a, __m256i idx, __mmask8 k, __m256d b);</p>
<p>VPERMT2PD __m256d _mm256_maskz_permutex2var_pd(__mmask8 k, __m256d a, __m256i idx, __m256d b);</p>
<p>VPERMT2PD __m128d _mm_permutex2var_pd(__m128d a, __m128i idx, __m128d b);</p>
<p>VPERMT2PD __m128d _mm_mask_permutex2var_pd(__m128d a, __mmask8 k, __m128i idx, __m128d b);</p>
<p>VPERMT2PD __m128d _mm_mask2_permutex2var_pd(__m128d a, __m128i idx, __mmask8 k, __m128d b);</p>
<p>VPERMT2PD __m128d _mm_maskz_permutex2var_pd(__mmask8 k, __m128d a, __m128i idx, __m128d b);</p>
<p>VPERMT2PS __m512 _mm512_permutex2var_ps(__m512 a, __m512i idx, __m512 b);</p>
<p>VPERMT2PS __m512 _mm512_mask_permutex2var_ps(__m512 a, __mmask16 k, __m512i idx, __m512 b);</p>
<p>VPERMT2PS __m512 _mm512_mask2_permutex2var_ps(__m512 a, __m512i idx, __mmask16 k, __m512 b);</p>
<p>VPERMT2PS __m512 _mm512_maskz_permutex2var_ps(__mmask16 k, __m512 a, __m512i idx, __m512 b);</p>
<p>VPERMT2PS __m256 _mm256_permutex2var_ps(__m256 a, __m256i idx, __m256 b);</p>
<p>VPERMT2PS __m256 _mm256_mask_permutex2var_ps(__m256 a, __mmask8 k, __m256i idx, __m256 b);</p>
<p>VPERMT2PS __m256 _mm256_mask2_permutex2var_ps(__m256 a, __m256i idx, __mmask8 k, __m256 b);</p>
<p>VPERMT2PS __m256 _mm256_maskz_permutex2var_ps(__mmask8 k, __m256 a, __m256i idx, __m256 b);</p>
<p>VPERMT2PS __m128 _mm_permutex2var_ps(__m128 a, __m128i idx, __m128 b);</p>
<p>VPERMT2PS __m128 _mm_mask_permutex2var_ps(__m128 a, __mmask8 k, __m128i idx, __m128 b);</p>
<p>VPERMT2PS __m128 _mm_mask2_permutex2var_ps(__m128 a, __m128i idx, __mmask8 k, __m128 b);</p>
<p>VPERMT2PS __m128 _mm_maskz_permutex2var_ps(__mmask8 k, __m128 a, __m128i idx, __m128 b);</p>
<p>VPERMT2Q __m512i _mm512_permutex2var_epi64(__m512i a, __m512i idx, __m512i b);</p>
<p>VPERMT2Q __m512i _mm512_mask_permutex2var_epi64(__m512i a, __mmask8 k, __m512i idx, __m512i b);</p>
<p>VPERMT2Q __m512i _mm512_mask2_permutex2var_epi64(__m512i a, __m512i idx, __mmask8 k, __m512i b);</p>
<p>VPERMT2Q __m512i _mm512_maskz_permutex2var_epi64(__mmask8 k, __m512i a, __m512i idx, __m512i b);</p>
<p>VPERMT2Q __m256i _mm256_permutex2var_epi64(__m256i a, __m256i idx, __m256i b);</p>
<p>VPERMT2Q __m256i _mm256_mask_permutex2var_epi64(__m256i a, __mmask8 k, __m256i idx, __m256i b);</p>
<p>VPERMT2Q __m256i _mm256_mask2_permutex2var_epi64(__m256i a, __m256i idx, __mmask8 k, __m256i b);</p>
<p>VPERMT2Q __m256i _mm256_maskz_permutex2var_epi64(__mmask8 k, __m256i a, __m256i idx, __m256i b);</p>
<p>VPERMT2Q __m128i _mm_permutex2var_epi64(__m128i a, __m128i idx, __m128i b);</p>
<p>VPERMT2Q __m128i _mm_mask_permutex2var_epi64(__m128i a, __mmask8 k, __m128i idx, __m128i b);</p>
<p>VPERMT2Q __m128i _mm_mask2_permutex2var_epi64(__m128i a, __m128i idx, __mmask8 k, __m128i b);</p>
<p>VPERMT2Q __m128i _mm_maskz_permutex2var_epi64(__mmask8 k, __m128i a, __m128i idx, __m128i b);</p>
<p>VPERMT2W __m512i _mm512_permutex2var_epi16(__m512i a, __m512i idx, __m512i b);</p>
<p>VPERMT2W __m512i _mm512_mask_permutex2var_epi16(__m512i a, __mmask32 k, __m512i idx, __m512i b);</p>
<p>VPERMT2W __m512i _mm512_mask2_permutex2var_epi16(__m512i a, __m512i idx, __mmask32 k, __m512i b);</p>
<p>VPERMT2W __m512i _mm512_maskz_permutex2var_epi16(__mmask32 k, __m512i a, __m512i idx, __m512i b);</p>
<p>VPERMT2W __m256i _mm256_permutex2var_epi16(__m256i a, __m256i idx, __m256i b);</p>
<p>VPERMT2W __m256i _mm256_mask_permutex2var_epi16(__m256i a, __mmask16 k, __m256i idx, __m256i b);</p>
<p>VPERMT2W __m256i _mm256_mask2_permutex2var_epi16(__m256i a, __m256i idx, __mmask16 k, __m256i b);</p>
<p>VPERMT2W __m256i _mm256_maskz_permutex2var_epi16(__mmask16 k, __m256i a, __m256i idx, __m256i b);</p>
<p>VPERMT2W __m128i _mm_permutex2var_epi16(__m128i a, __m128i idx, __m128i b);</p>
<p>VPERMT2W __m128i _mm_mask_permutex2var_epi16(__m128i a, __mmask8 k, __m128i idx, __m128i b);</p>
<p>VPERMT2W __m128i _mm_mask2_permutex2var_epi16(__m128i a, __m128i idx, __mmask8 k, __m128i b);</p>
<p>VPERMT2W __m128i _mm_maskz_permutex2var_epi16(__mmask8 k, __m128i a, __m128i idx, __m128i b);</p>
<p><strong>SIMD Floating-Point Exceptions</strong></p>
<p>None.</p>
<p><strong>Other Exceptions</strong></p>
<table>
<tr>
<td>VPERMT2D/Q/PS/PD: See Table 2-50, “Type E4NF Class Exception Conditions.”</td></tr>
<tr>
<td>VPERMT2W: See Exceptions Type E4NF.nb in Table 2-50, “Type E4NF Class Exception Conditions.”</td></tr></table></div></body></html>