<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="style.css">
<script src="script.js"></script>
<title>VF[,N]MSUB[132,213,231]PH - Fused Multiply-Subtract of Packed FP16 Values </title></head>
<body>
<div id="head">
<a href="index.html">x86doc</a> › VF[,N]MSUB[132,213,231]PH - Fused Multiply-Subtract of Packed FP16 Values </div>
<div id="body">
<h1>VF[,N]MSUB[132,213,231]PH—Fused Multiply-Subtract of Packed FP16 Values</h1>
<table>
<tr>
<th>Opcode/Instruction</th>
<th>Op/En</th>
<th>64/32 bit Mode Support</th>
<th>CPUID Feature Flag</th>
<th>Description</th></tr>
<tr>
<td>
<p>EVEX.128.66.MAP6.W0  9A  /r</p>
<p>VFMSUB132PH xmm1{k1}{z}, xmm2, xmm3/m128/m16bcst</p></td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16 AVX512VL</td>
<td>Multiply packed FP16 values from xmm1 and xmm3/m128/m16bcst, subtract xmm2, and store the result in xmm1 subject to writemask k1.</td></tr>
<tr>
<td>
<p>EVEX.256.66.MAP6.W0  9A  /r</p>
<p>VFMSUB132PH ymm1{k1}{z}, ymm2, ymm3/m256/m16bcst</p></td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16 AVX512VL</td>
<td>Multiply packed FP16 values from ymm1 and ymm3/m256/m16bcst, subtract ymm2, and store the result in ymm1 subject to writemask k1.</td></tr>
<tr>
<td>EVEX.512.66.MAP6.W0  9A  /r VFMSUB132PH  zmm1{k1}{z},  zmm2, zmm3/m512/m16bcst  {er}</td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16</td>
<td>Multiply packed FP16 values from zmm1 and zmm3/m512/m16bcst, subtract zmm2, and store the result in zmm1 subject to writemask k1.</td></tr>
<tr>
<td>
<p>EVEX.128.66.MAP6.W0  AA  /r</p>
<p>VFMSUB213PH xmm1{k1}{z}, xmm2, xmm3/m128/m16bcst</p></td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16 AVX512VL</td>
<td>Multiply packed FP16 values from xmm1 and xmm2, subtract xmm3/m128/m16bcst, and store the result in xmm1 subject to writemask k1.</td></tr>
<tr>
<td>
<p>EVEX.256.66.MAP6.W0  AA  /r</p>
<p>VFMSUB213PH ymm1{k1}{z}, ymm2, ymm3/m256/m16bcst</p></td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16 AVX512VL</td>
<td>Multiply packed FP16 values from ymm1 and ymm2, subtract ymm3/m256/m16bcst, and store the result in ymm1 subject to writemask k1.</td></tr>
<tr>
<td>EVEX.512.66.MAP6.W0  AA  /r VFMSUB213PH  zmm1{k1}{z},  zmm2, zmm3/m512/m16bcst  {er}</td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16</td>
<td>Multiply packed FP16 values from zmm1 and zmm2, subtract zmm3/m512/m16bcst, and store the result in zmm1 subject to writemask k1.</td></tr>
<tr>
<td>
<p>EVEX.128.66.MAP6.W0  BA  /r</p>
<p>VFMSUB231PH xmm1{k1}{z}, xmm2, xmm3/m128/m16bcst</p></td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16 AVX512VL</td>
<td>Multiply packed FP16 values from xmm2 and xmm3/m128/m16bcst, subtract xmm1, and store the result in xmm1 subject to writemask k1.</td></tr>
<tr>
<td>
<p>EVEX.256.66.MAP6.W0  BA  /r</p>
<p>VFMSUB231PH ymm1{k1}{z}, ymm2, ymm3/m256/m16bcst</p></td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16 AVX512VL</td>
<td>Multiply packed FP16 values from ymm2 and ymm3/m256/m16bcst, subtract ymm1, and store the result in ymm1 subject to writemask k1.</td></tr>
<tr>
<td>EVEX.512.66.MAP6.W0  BA  /r VFMSUB231PH  zmm1{k1}{z},  zmm2, zmm3/m512/m16bcst  {er}</td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16</td>
<td>Multiply packed FP16 values from zmm2 and zmm3/m512/m16bcst, subtract zmm1, and store the result in zmm1 subject to writemask k1.</td></tr>
<tr>
<td>EVEX.128.66.MAP6.W0  9E  /r VFNMSUB132PH  xmm1{k1}{z}, xmm2,  xmm3/m128/m16bcst</td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16 AVX512VL</td>
<td>Multiply packed FP16 values from xmm1 and xmm3/m128/m16bcst, and negate the value. Subtract xmm2 from this value, and store the result in xmm1 subject to writemask k1.</td></tr>
<tr>
<td>EVEX.256.66.MAP6.W0  9E  /r VFNMSUB132PH  ymm1{k1}{z}, ymm2,  ymm3/m256/m16bcst</td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16 AVX512VL</td>
<td>Multiply packed FP16 values from ymm1 and ymm3/m256/m16bcst, and negate the value. Subtract ymm2 from this value, and store the result in ymm1 subject to writemask k1.</td></tr>
<tr>
<td>EVEX.512.66.MAP6.W0  9E  /r VFNMSUB132PH  zmm1{k1}{z}, zmm2,  zmm3/m512/m16bcst  {er}</td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16</td>
<td>Multiply packed FP16 values from zmm1 and zmm3/m512/m16bcst, and negate the value. Subtract zmm2 from this value, and store the result in zmm1 subject to writemask k1.</td></tr>
<tr>
<td>EVEX.128.66.MAP6.W0  AE  /r VFNMSUB213PH  xmm1{k1}{z}, xmm2,  xmm3/m128/m16bcst</td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16 AVX512VL</td>
<td>Multiply packed FP16 values from xmm1 and xmm2, and negate the value. Subtract xmm3/m128/m16bcst from this value, and store the result in xmm1 subject to writemask k1.</td></tr>
<tr>
<td>EVEX.256.66.MAP6.W0  AE  /r VFNMSUB213PH  ymm1{k1}{z}, ymm2,  ymm3/m256/m16bcst</td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16 AVX512VL</td>
<td>Multiply packed FP16 values from ymm1 and ymm2, and negate the value. Subtract ymm3/m256/m16bcst from this value, and store the result in ymm1 subject to writemask k1.</td></tr></table>
<p><strong>Opcode/</strong></p>
<p><strong>Op/</strong></p>
<p><strong>64/32</strong></p>
<p><strong>CPUID Feature</strong></p>
<p><strong>Description</strong></p>
<table>
<tr>
<th>Instruction</th>
<th>En</th>
<th>bit Mode Support</th>
<th>Flag</th>
<th></th></tr>
<tr>
<td>EVEX.512.66.MAP6.W0  AE  /r VFNMSUB213PH  zmm1{k1}{z}, zmm2,  zmm3/m512/m16bcst  {er}</td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16</td>
<td>Multiply packed FP16 values from zmm1 and zmm2, and negate the value. Subtract zmm3/m512/m16bcst from this value, and store the result in zmm1 subject to writemask k1.</td></tr>
<tr>
<td>EVEX.128.66.MAP6.W0  BE  /r VFNMSUB231PH  xmm1{k1}{z}, xmm2,  xmm3/m128/m16bcst</td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16 AVX512VL</td>
<td>Multiply packed FP16 values from xmm2 and xmm3/m128/m16bcst, and negate the value. Subtract xmm1 from this value, and store the result in xmm1 subject to writemask k1.</td></tr>
<tr>
<td>EVEX.256.66.MAP6.W0  BE  /r VFNMSUB231PH  ymm1{k1}{z}, ymm2,  ymm3/m256/m16bcst</td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16 AVX512VL</td>
<td>Multiply packed FP16 values from ymm2 and ymm3/m256/m16bcst, and negate the value. Subtract ymm1 from this value, and store the result in ymm1 subject to writemask k1.</td></tr>
<tr>
<td>EVEX.512.66.MAP6.W0  BE  /r VFNMSUB231PH  zmm1{k1}{z}, zmm2,  zmm3/m512/m16bcst  {er}</td>
<td>A</td>
<td>V/V</td>
<td>AVX512-FP16</td>
<td>Multiply packed FP16 values from zmm2 and zmm3/m512/m16bcst, and negate the value. Subtract zmm1 from this value, and store the result in zmm1 subject to writemask k1.</td></tr></table>
<h3>Instruction Operand Encoding</h3>
<table>
<tr>
<th>Op/En</th>
<th>Tuple</th>
<th>Operand 1</th>
<th>Operand 2</th>
<th>Operand 3</th>
<th>Operand 4</th></tr>
<tr>
<td>A</td>
<td>Full</td>
<td>ModRM:reg (r, w)</td>
<td>VEX.vvvv (r)</td>
<td>ModRM:r/m (r)</td>
<td>N/A</td></tr></table>
<p><strong>Description</strong></p>
<p>This instruction performs a packed multiply-subtract or a negated multiply-subtract computation on FP16 values using three source operands and writes the results in the destination operand. The destination operand is also the first source operand. The “N” (negated) forms of this instruction subtract the remaining operand from the negated infinite precision intermediate product. The notation’ “132”, “213” and “231” indicate the use of the operands in ±A * B − C, where each digit corresponds to the operand number, with the destination being operand 1; see Table 5-5.</p>
<p>The destination elements are updated according to the writemask.</p>
<h3>Table 5-5.  VF[,N]MSUB[132,213,231]PH Notation for Operands</h3>
<table>
<tr>
<th>Notation</th>
<th>
<p><strong>Operands</strong></p>
<p>dest = ± dest*src3-src2</p></th></tr>
<tr>
<td>132</td>
<td>dest = ± src2*src3-dest</td></tr>
<tr>
<td>231</td>
<td>dest = ± src2*dest-src3</td></tr>
<tr>
<td>213</td>
<td></td></tr></table>
<p><strong>Operation</strong></p>
<p><strong>VF[,N]MSUB132PH DEST, SRC2, SRC3 (EVEX encoded versions) when src3 operand is a register</strong></p>
<p>VL = 128, 256 or 512</p>
<p>KL := VL/16</p>
<p>IF (VL = 512) AND (EVEX.b = 1):</p>
<p>SET_RM(EVEX.RC)</p>
<p>ELSE</p>
<p>SET_RM(MXCSR.RC)</p>
<p>FOR j := 0 TO KL-1:</p>
<p>IF k1[j] OR *no writemask*:</p>
<p>IF *negative form*:</p>
<p>DEST.fp16[j] := RoundFPControl(-DEST.fp16[j]*SRC3.fp16[j] - SRC2.fp16[j])</p>
<p>ELSE:</p>
<p>DEST.fp16[j] := RoundFPControl(DEST.fp16[j]*SRC3.fp16[j] - SRC2.fp16[j])</p>
<p>ELSE IF *zeroing*:</p>
<p>DEST.fp16[j] := 0</p>
<p>// else dest.fp16[j] remains unchanged</p>
<p>DEST[MAXVL-1:VL] := 0</p>
<p><strong>VF[,N]MSUB132PH DEST, SRC2, SRC3 (EVEX encoded versions) when src3 operand is a memory source</strong></p>
<p>VL = 128, 256 or 512</p>
<p>KL := VL/16</p>
<p>FOR j := 0 TO KL-1:</p>
<p>IF k1[j] OR *no writemask*:</p>
<p>IF EVEX.b = 1:</p>
<p>t3 := SRC3.fp16[0]</p>
<p>ELSE:</p>
<p>t3 := SRC3.fp16[j]</p>
<p>IF *negative form*:</p>
<p>DEST.fp16[j] := RoundFPControl(-DEST.fp16[j] * t3 - SRC2.fp16[j])</p>
<p>ELSE:</p>
<p>DEST.fp16[j] := RoundFPControl(DEST.fp16[j] * t3 - SRC2.fp16[j])</p>
<p>ELSE IF *zeroing*:</p>
<p>DEST.fp16[j] := 0</p>
<p>// else dest.fp16[j] remains unchanged</p>
<p>DEST[MAXVL-1:VL] := 0</p>
<p><strong>VF[,N]MSUB213PH DEST, SRC2, SRC3 (EVEX encoded versions) when src3 operand is a register</strong></p>
<p>VL = 128, 256 or 512</p>
<p>KL := VL/16</p>
<p>IF (VL = 512) AND (EVEX.b = 1):</p>
<p>SET_RM(EVEX.RC)</p>
<p>ELSE</p>
<p>SET_RM(MXCSR.RC)</p>
<p>FOR j := 0 TO KL-1:</p>
<p>IF k1[j] OR *no writemask*:</p>
<p>IF *negative form*:</p>
<p>DEST.fp16[j] := RoundFPControl(-SRC2.fp16[j]*DEST.fp16[j] - SRC3.fp16[j])</p>
<p>ELSE</p>
<p>DEST.fp16[j] := RoundFPControl(SRC2.fp16[j]*DEST.fp16[j] - SRC3.fp16[j])</p>
<p>ELSE IF *zeroing*:</p>
<p>DEST.fp16[j] := 0</p>
<p>// else dest.fp16[j] remains unchanged</p>
<p>DEST[MAXVL-1:VL] := 0</p>
<p><strong>VF[,N]MSUB213PH DEST, SRC2, SRC3 (EVEX encoded versions) when src3 operand is a memory source</strong></p>
<p>VL = 128, 256 or 512</p>
<p>KL := VL/16</p>
<p>FOR j := 0 TO KL-1:</p>
<p>IF k1[j] OR *no writemask*:</p>
<p>IF EVEX.b = 1:</p>
<p>t3 := SRC3.fp16[0]</p>
<p>ELSE:</p>
<p>t3 := SRC3.fp16[j]</p>
<p>IF *negative form*:</p>
<p>DEST.fp16[j] := RoundFPControl(-SRC2.fp16[j] * DEST.fp16[j] - t3 )</p>
<p>ELSE:</p>
<p>DEST.fp16[j] := RoundFPControl(SRC2.fp16[j] * DEST.fp16[j] - t3 )</p>
<p>ELSE IF *zeroing*:</p>
<p>DEST.fp16[j] := 0</p>
<p>// else dest.fp16[j] remains unchanged</p>
<p>DEST[MAXVL-1:VL] := 0</p>
<p><strong>VF[,N]MSUB231PH DEST, SRC2, SRC3 (EVEX encoded versions) when src3 operand is a register</strong></p>
<p>VL = 128, 256 or 512</p>
<p>KL := VL/16</p>
<p>IF (VL = 512) AND (EVEX.b = 1):</p>
<p>SET_RM(EVEX.RC)</p>
<p>ELSE</p>
<p>SET_RM(MXCSR.RC)</p>
<p>FOR j := 0 TO KL-1:</p>
<p>IF k1[j] OR *no writemask*:</p>
<p>IF *negative form:</p>
<p>DEST.fp16[j] := RoundFPControl(-SRC2.fp16[j]*SRC3.fp16[j] - DEST.fp16[j])</p>
<p>ELSE:</p>
<p>DEST.fp16[j] := RoundFPControl(SRC2.fp16[j]*SRC3.fp16[j] - DEST.fp16[j])</p>
<p>ELSE IF *zeroing*:</p>
<p>DEST.fp16[j] := 0</p>
<p>// else dest.fp16[j] remains unchanged</p>
<p>DEST[MAXVL-1:VL] := 0</p>
<p><strong>VF[,N]MSUB231PH DEST, SRC2, SRC3 (EVEX encoded versions) when src3 operand is a memory source</strong></p>
<p>VL = 128, 256 or 512</p>
<p>KL := VL/16</p>
<p>FOR j := 0 TO KL-1:</p>
<p>IF k1[j] OR *no writemask*:</p>
<p>IF EVEX.b = 1:</p>
<p>t3 := SRC3.fp16[0]</p>
<p>ELSE:</p>
<p>t3 := SRC3.fp16[j]</p>
<p>IF *negative form*:</p>
<p>DEST.fp16[j] := RoundFPControl(-SRC2.fp16[j] * t3 - DEST.fp16[j] )</p>
<p>ELSE:</p>
<p>DEST.fp16[j] := RoundFPControl(SRC2.fp16[j] * t3 - DEST.fp16[j] )</p>
<p>ELSE IF *zeroing*:</p>
<p>DEST.fp16[j] := 0</p>
<p>// else dest.fp16[j] remains unchanged</p>
<p>DEST[MAXVL-1:VL] := 0</p>
<p><strong>Intel C/C++ Compiler Intrinsic Equivalent</strong></p>
<p>VFMSUB132PH, VFMSUB213PH, and VFMSUB231PH:</p>
<p>__m128h _mm_fmsub_ph (__m128h a, __m128h b, __m128h c);</p>
<p>__m128h _mm_mask_fmsub_ph (__m128h a, __mmask8 k, __m128h b, __m128h c);</p>
<p>__m128h _mm_mask3_fmsub_ph (__m128h a, __m128h b, __m128h c, __mmask8 k);</p>
<p>__m128h _mm_maskz_fmsub_ph (__mmask8 k, __m128h a, __m128h b, __m128h c);</p>
<p>__m256h _mm256_fmsub_ph (__m256h a, __m256h b, __m256h c);</p>
<p>__m256h _mm256_mask_fmsub_ph (__m256h a, __mmask16 k, __m256h b, __m256h c);</p>
<p>__m256h _mm256_mask3_fmsub_ph (__m256h a, __m256h b, __m256h c, __mmask16 k);</p>
<p>__m256h _mm256_maskz_fmsub_ph (__mmask16 k, __m256h a, __m256h b, __m256h c);</p>
<p>__m512h _mm512_fmsub_ph (__m512h a, __m512h b, __m512h c);</p>
<p>__m512h _mm512_mask_fmsub_ph (__m512h a, __mmask32 k, __m512h b, __m512h c);</p>
<p>__m512h _mm512_mask3_fmsub_ph (__m512h a, __m512h b, __m512h c, __mmask32 k);</p>
<p>__m512h _mm512_maskz_fmsub_ph (__mmask32 k, __m512h a, __m512h b, __m512h c);</p>
<p>__m512h _mm512_fmsub_round_ph (__m512h a, __m512h b, __m512h c, const int rounding);</p>
<p>__m512h _mm512_mask_fmsub_round_ph (__m512h a, __mmask32 k, __m512h b, __m512h c, const int rounding);</p>
<p>__m512h _mm512_mask3_fmsub_round_ph (__m512h a, __m512h b, __m512h c, __mmask32 k, const int rounding);</p>
<p>__m512h _mm512_maskz_fmsub_round_ph (__mmask32 k, __m512h a, __m512h b, __m512h c, const int rounding);</p>
<p>VFNMSUB132PH, VFNMSUB213PH, and VFNMSUB231PH:</p>
<p>__m128h _mm_fnmsub_ph (__m128h a, __m128h b, __m128h c);</p>
<p>__m128h _mm_mask_fnmsub_ph (__m128h a, __mmask8 k, __m128h b, __m128h c);</p>
<p>__m128h _mm_mask3_fnmsub_ph (__m128h a, __m128h b, __m128h c, __mmask8 k);</p>
<p>__m128h _mm_maskz_fnmsub_ph (__mmask8 k, __m128h a, __m128h b, __m128h c);</p>
<p>__m256h _mm256_fnmsub_ph (__m256h a, __m256h b, __m256h c);</p>
<p>__m256h _mm256_mask_fnmsub_ph (__m256h a, __mmask16 k, __m256h b, __m256h c);</p>
<p>__m256h _mm256_mask3_fnmsub_ph (__m256h a, __m256h b, __m256h c, __mmask16 k);</p>
<p>__m256h _mm256_maskz_fnmsub_ph (__mmask16 k, __m256h a, __m256h b, __m256h c);</p>
<p>__m512h _mm512_fnmsub_ph (__m512h a, __m512h b, __m512h c);</p>
<p>__m512h _mm512_mask_fnmsub_ph (__m512h a, __mmask32 k, __m512h b, __m512h c);</p>
<p>__m512h _mm512_mask3_fnmsub_ph (__m512h a, __m512h b, __m512h c, __mmask32 k);</p>
<p>__m512h _mm512_maskz_fnmsub_ph (__mmask32 k, __m512h a, __m512h b, __m512h c);</p>
<p>__m512h _mm512_fnmsub_round_ph (__m512h a, __m512h b, __m512h c, const int rounding);</p>
<p>__m512h _mm512_mask_fnmsub_round_ph (__m512h a, __mmask32 k, __m512h b, __m512h c, const int rounding);</p>
<p>__m512h _mm512_mask3_fnmsub_round_ph (__m512h a, __m512h b, __m512h c, __mmask32 k, const int rounding);</p>
<p>__m512h _mm512_maskz_fnmsub_round_ph (__mmask32 k, __m512h a, __m512h b, __m512h c, const int rounding);</p>
<p><strong>SIMD Floating-Point Exceptions</strong></p>
<p>Invalid, Underflow, Overflow, Precision, Denormal.</p>
<p><strong>Other Exceptions</strong></p>
<p>EVEX-encoded instructions, see Table 2-46, “Type E2 Class Exception Conditions.”</p></div></body></html>